<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PGP Decryption Tool</title>
    <link rel="stylesheet" href="https://unpkg.com/mdui@1.0.2/dist/css/mdui.min.css">
    <script src="https://unpkg.com/mdui@1.0.2/dist/js/mdui.min.js"></script>

    <style>
        body {
            max-width: 800px;
            margin: 0 auto;
            padding: 15px;
            background-color: var(--mdui-color-background);
            color: var(--mdui-color-text);
        }
        
        textarea, #dropArea {
            width: 100%;
            box-sizing: border-box;
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
            background-color: var(--mdui-color-surface);
            color: var(--mdui-color-text);
            transition: all 0.3s;
        }
        
        textarea {
            resize: vertical;
            min-height: 100px;
            border: 1px solid rgba(0,0,0,0.12);
        }
        
        #dropArea {
            border: 2px dashed rgba(0,0,0,0.12);
            padding: 25px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        #dropArea.highlight {
            border-color: var(--mdui-color-primary);
            background-color: var(--mdui-color-primary-container);
            color: var(--mdui-color-on-primary-container);
        }

        .yubikey-status {
            display: flex;
            align-items: center;
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
            background-color: var(--mdui-color-surface-variant);
            cursor: pointer; /* 添加指针样式表明可点击 */
            position: relative;
        }

        .yubikey-status .help-icon {
            position: absolute;
            right: 10px;
            color: var(--mdui-color-primary);
            cursor: help;
        }

        .yubikey-status .status-icon {
            margin-right: 10px;
        }

        .status-connecting {
            color: var(--mdui-color-warning);
        }

        .status-ready {
            color: var(--mdui-color-success);
        }

        .status-error {
            color: var(--mdui-color-error);
        }

        @media (prefers-color-scheme: dark) {
            body {
                background-color: var(--mdui-color-surface);
                color: var (--mdui-color-on-surface);
            }
            
            textarea, #dropArea {
                background-color: var(--mdui-color-surface-container);
                color: var (--mdui-color-on-surface);
                border-color: rgba(255,255,255,0.12);
            }
        }

        /* PIN输入对话框样式 */
        .pin-dialog {
            max-width: 300px;
            margin: 0 auto;
        }
        
        .pin-input {
            letter-spacing: 0.5em;
            text-align: center;
            font-family: monospace;
        }
        
        .pin-error {
            color: var(--mdui-color-error);
            font-size: 0.85em;
            margin-top: 8px;
            display: none;
        }

        /* 解密结果区域样式 */
        #decryptedContent {
            margin-top: 20px;
            display: none;
        }

        .signature-info {
            margin-top: 10px;
            padding: 8px;
            border-radius: 4px;
            background-color: var(--mdui-color-surface-variant);
        }

        .signature-valid {
            color: var(--mdui-color-success);
        }

        .signature-invalid {
            color: var(--mdui-color-error);
        }
    </style>
</head>
<body class="mdui-theme-primary-indigo mdui-theme-accent-blue">
    <div class="section mdui-typo">
        <h2 class="mdui-typo-headline" style="text-align: center;">PGP Decryption Tool</h2>
        <p>Decrypt your PGP messages using Yubikey securely in your browser.</p>
    </div>

    <div class="yubikey-status mdui-shadow-1">
        <i class="mdui-icon material-icons status-icon status-connecting">sync</i>
        <span>Waiting for Yubikey...</span>
        <i class="mdui-icon material-icons help-icon" id="helpBtn" title="USB Device Help">help_outline</i>
    </div>

    <div class="section">
        <div class="mode-buttons mdui-btn-group">
            <button id="textModeBtn" class="mdui-btn mdui-btn-raised mdui-ripple mdui-color-blue-a400">
                <i class="mdui-icon material-icons">text_fields</i> Text
            </button>
            <button id="fileModeBtn" class="mdui-btn mdui-color-white mdui-shadow-1 mdui-ripple">
                <i class="mdui-icon material-icons">file_upload</i> File
            </button>
        </div>
        
        <div class="input-container mdui-textfield mdui-textfield-floating-label">
            <textarea id="ciphertext" class="mdui-textfield-input mdui-ripple mdui-shadow-1 mdui-color-grey-200" 
                      placeholder="Paste your encrypted PGP message here"></textarea>
            
            <div id="dropArea" class="hidden mdui-shadow-1 mdui-color-white">
                Drag encrypted file here or click to upload
                <input type="file" id="fileInput" style="display:none;" accept=".gpg,.asc" />
            </div>
            <div id="fileInfo" class="mdui-typo-caption-opacity"></div>
        </div>

        <div class="mdui-btn-group">
            <button id="pasteBtn" class="mdui-btn mdui-btn-raised mdui-ripple mdui-color-white">
                <i class="mdui-icon material-icons">content_paste</i> Paste
            </button>
            <button id="clearBtn" class="mdui-btn mdui-ripple mdui-color-white">
                <i class="mdui-icon material-icons">clear</i> Clear
            </button>
            <button id="decryptBtn" class="mdui-btn mdui-btn-raised mdui-ripple mdui-color-theme" disabled>
                <i class="mdui-icon material-icons">lock_open</i> Decrypt
            </button>
        </div>
    </div>

    <!-- OpenPGP.js -->
    <script src="https://unpkg.com/openpgp@5.9.0/dist/openpgp.min.js"></script>
    <!-- WebUSB Polyfill -->
    <script src="https://gcore.jsdelivr.net/npm/webusb/dist/webusb.js"></script>
    
    <script>
        (function() {
            // 常量定义
            const YUBIKEY_VENDOR_ID = 0x1050;
            const OpenPGP_AID = new Uint8Array([0xD2, 0x76, 0x00, 0x01, 0x24, 0x01]);
            const INS = {
                VERIFY: 0x20,
                GET_DATA: 0xCA,
                PUT_DATA: 0xDA,
                GENERATE: 0x47,
                AUTHENTICATE: 0x87
            };

            // 全局变量
            let yubikey = null;
            let currentMode = 'text';
            let pinAttempts = 3;
            let privateKey = null; // 将从Yubikey获取
            
            // DOM元素
            const textModeBtn = document.getElementById('textModeBtn');
            const fileModeBtn = document.getElementById('fileModeBtn');
            const ciphertext = document.getElementById('ciphertext');
            const dropArea = document.getElementById('dropArea');
            const fileInput = document.getElementById('fileInput');
            const fileInfo = document.getElementById('fileInfo');
            const decryptBtn = document.getElementById('decryptBtn');
            const pasteBtn = document.getElementById('pasteBtn');
            const clearBtn = document.getElementById('clearBtn');
            const yubikeyStatus = document.querySelector('.yubikey-status');
            
            // 检查WebUSB支持
            function checkWebUSBSupport() {
                if (!navigator.usb) {
                    // 检测是否为移动设备
                    const isMobile = /Android|iPhone|iPad|iPod|webOS/i.test(navigator.userAgent);
                    if (isMobile) {
                        updateYubikeyStatus('error', 'Mobile devices do not support WebUSB. Please use a desktop browser or <a href="https://www.openkeychain.org/">OpenKeychain</a>');
                    } else {
                        updateYubikeyStatus('error', 'WebUSB not supported in this browser. Please use Chrome or Edge.');
                    }
                    return false;
                }
                return true;
            }
            
            // 更新Yubikey状态显示
            function updateYubikeyStatus(status, message) {
                const statusIcon = yubikeyStatus.querySelector('.status-icon');
                const statusText = yubikeyStatus.querySelector('span');
                
                statusIcon.className = 'mdui-icon material-icons status-icon';
                switch(status) {
                    case 'connecting':
                        statusIcon.classList.add('status-connecting');
                        statusIcon.textContent = 'sync';
                        break;
                    case 'ready':
                        statusIcon.classList.add('status-ready');
                        statusIcon.textContent = 'check_circle';
                        break;
                    case 'error':
                        statusIcon.classList.add('status-error');
                        statusIcon.textContent = 'error';
                        break;
                }
                
                statusText.textContent = message;
            }
            
            // Yubikey通信类
            class YubikeyPGP {
                constructor(device) {
                    this.device = device;
                    this.iface = null;  // Changed from interface to iface
                    this.endpoint = null;
                }

                async connect() {
                    try {
                        await this.device.open();
                        
                        // 添加更多的错误处理和状态反馈
                        if (!this.device.opened) {
                            throw new Error('Failed to open device');
                        }
                        
                        if (this.device.configuration === null) {
                            await this.device.selectConfiguration(1);
                        }

                        // 获取接口更安全的方法
                        if (!this.device.configuration || !this.device.configuration.interfaces || this.device.configuration.interfaces.length === 0) {
                            throw new Error('Device has no available interfaces');
                        }

                        const iface = this.device.configuration.interfaces[0];
                        
                        try {
                            await this.device.claimInterface(iface.interfaceNumber);
                        } catch (e) {
                            throw new Error(`Failed to claim interface: ${e.message}`);
                        }
                        
                        // 检查端点
                        if (!iface.alternate || !iface.alternate.endpoints || iface.alternate.endpoints.length === 0) {
                            throw new Error('Interface has no endpoints');
                        }
                        
                        this.iface = iface;
                        this.endpoint = iface.alternate.endpoints[0];

                        await this.selectApplication(OpenPGP_AID);
                        return true;
                    } catch (error) {
                        console.error('Yubikey connection detail error:', error);
                        // 如果设备已经打开，尝试释放接口并关闭
                        if (this.device.opened) {
                            try {
                                if (this.iface) {
                                    await this.device.releaseInterface(this.iface.interfaceNumber);
                                }
                                await this.device.close();
                            } catch (closeError) {
                                console.error('Error closing device:', closeError);
                            }
                        }
                        throw error;
                    }
                }

                async selectApplication(aid) {
                    const result = await this.transmit(0x00, 0xA4, 0x04, 0x00, aid);
                    if (!this.isSuccessResponse(result)) {
                        throw new Error('Failed to select OpenPGP application');
                    }
                }

                async verifyPin(pin) {
                    const pinBuffer = new TextEncoder().encode(pin);
                    const result = await this.transmit(0x00, INS.VERIFY, 0x00, 0x82, pinBuffer);
                    return this.isSuccessResponse(result);
                }

                async getPublicKey() {
                    const result = await this.transmit(0x00, INS.GET_DATA, 0x00, 0x82, null);
                    if (!this.isSuccessResponse(result)) {
                        throw new Error('Failed to get public key');
                    }
                    return result.slice(0, -2);
                }

                async decrypt(encryptedData) {
                    // 实现解密操作
                    const result = await this.transmit(0x00, INS.AUTHENTICATE, 0x07, 0x00, encryptedData);
                    if (!this.isSuccessResponse(result)) {
                        throw new Error('Decryption failed');
                    }
                    return result.slice(0, -2);
                }

                async transmit(cla, ins, p1, p2, data) {
                    const command = this.buildApdu(cla, ins, p1, p2, data);
                    const response = await this.device.transferOut(this.endpoint.endpointNumber, command);
                    const result = await this.device.transferIn(this.endpoint.endpointNumber, 64);
                    return new Uint8Array(result.data.buffer);
                }

                buildApdu(cla, ins, p1, p2, data) {
                    const header = new Uint8Array([cla, ins, p1, p2]);
                    if (!data) {
                        return new Uint8Array([...header, 0x00]);
                    }
                    if (data.length > 255) {
                        throw new Error('Data too long');
                    }
                    return new Uint8Array([...header, data.length, ...data]);
                }

                isSuccessResponse(response) {
                    return response[response.length - 2] === 0x90 && 
                           response[response.length - 1] === 0x00;
                }
            }

            // key.openpgp.org API集成
            class KeyServer {
                static async getKey(keyId) {
                    try {
                        const response = await fetch(`https://keys.openpgp.org/vks/v1/by-keyid/${keyId}`);
                        if (!response.ok) {
                            throw new Error('Key not found');
                        }
                        const armored = await response.text();
                        return await openpgp.readKey({ armoredKey: armored });
                    } catch (error) {
                        console.error('Key server error:', error);
                        throw new Error('Failed to fetch key from server');
                    }
                }
            }

            // 连接Yubikey
            async function connectYubikey() {
                try {
                    // 显示连接中状态
                    updateYubikeyStatus('connecting', 'Connecting to Yubikey...');
                    
                    const device = await navigator.usb.requestDevice({
                        filters: [{ vendorId: YUBIKEY_VENDOR_ID }]
                    });
                    
                    yubikey = new YubikeyPGP(device);
                    await yubikey.connect();
                    updateYubikeyStatus('ready', 'Yubikey connected');
                    validateInput();
                    
                } catch (error) {
                    console.error('Yubikey connection error:', error);
                    
                    // 提供更具体的错误信息
                    if (error.name === 'NotFoundError') {
                        updateYubikeyStatus('error', 'No compatible device found. Make sure your Yubikey is plugged in.');
                    } else if (error.name === 'SecurityError') {
                        // Linux 特有问题
                        if (navigator.platform.includes('Linux')) {
                            updateYubikeyStatus('error', 'Permission denied. On Linux, you may need to add udev rules.');
                            showLinuxHelp();
                        } else {
                            updateYubikeyStatus('error', 'Access denied. Try a different USB port.');
                        }
                    } else {
                        updateYubikeyStatus('error', 'Failed to connect: ' + error.message);
                    }
                    
                    throw error;
                }
            }
            
            // 显示Linux帮助对话框
            function showLinuxHelp() {
                mdui.dialog({
                    title: 'Linux USB Permissions',
                    content: `
                        <p>On Linux, you need to add udev rules to access USB devices:</p>
                        <pre class="mdui-typo-pre">
# Create this file: /etc/udev/rules.d/70-yubikey.rules
SUBSYSTEM=="usb", ATTRS{idVendor}=="1050", ATTRS{idProduct}=="0407", MODE="0666"
SUBSYSTEM=="usb", ATTRS{idVendor}=="1050", ATTRS{idProduct}=="0113", MODE="0666"

# Then run
sudo udevadm control --reload-rules && sudo udevadm trigger</pre>
                    `,
                    buttons: [
                        {
                            text: 'OK'
                        }
                    ]
                });
            }

            // 显示PIN输入对话框
            function showPINDialog() {
                return new Promise((resolve, reject) => {
                    const dialog = new mdui.Dialog(`
                        <div class="pin-dialog mdui-dialog">
                            <div class="mdui-dialog-title">Enter PIN</div>
                            <div class="mdui-dialog-content">
                                <div class="mdui-textfield">
                                    <input type="password" class="mdui-textfield-input pin-input" 
                                           pattern="[0-9]*" inputmode="numeric" maxlength="8" 
                                           placeholder="Enter your PIN"/>
                                </div>
                                <div class="pin-error">Invalid PIN, ${pinAttempts} attempts remaining</div>
                            </div>
                            <div class="mdui-dialog-actions">
                                <button class="mdui-btn mdui-ripple" mdui-dialog-cancel>Cancel</button>
                                <button class="mdui-btn mdui-ripple" mdui-dialog-confirm>OK</button>
                            </div>
                        </div>
                    `, {
                        closeOnEsc: false,
                        modal: true
                    });
                    
                    const pinInput = dialog.$element.querySelector('.pin-input');
                    const errorDiv = dialog.$element.querySelector('.pin-error');
                    
                    dialog.open();
                    
                    dialog.$element.addEventListener('confirm', () => {
                        const pin = pinInput.value;
                        if (pin.length >= 4) {
                            resolve(pin);
                        } else {
                            errorDiv.textContent = 'PIN must be at least 4 digits';
                            errorDiv.style.display = 'block';
                            return false;
                        }
                    });
                    
                    dialog.$element.addEventListener('cancel', () => {
                        reject(new Error('PIN entry cancelled'));
                    });
                });
            }
            
            // 验证PIN
            async function verifyPIN(pin) {
                try {
                    const result = await yubikey.verifyPin(pin);
                    if (!result) {
                        pinAttempts--;
                        if (pinAttempts <= 0) {
                            throw new Error('PIN blocked');
                        }
                        throw new Error(`Invalid PIN, ${pinAttempts} attempts remaining`);
                    }
                    return true;
                } catch (error) {
                    console.error('PIN verification error:', error);
                    throw error;
                }
            }

            function switchMode(mode) {
                currentMode = mode;
                if (mode === 'text') {
                    textModeBtn.classList.add('mdui-color-blue-a400');
                    fileModeBtn.classList.remove('mdui-color-blue-a400');
                    ciphertext.classList.remove('hidden');
                    dropArea.classList.add('hidden');
                } else {
                    textModeBtn.classList.remove('mdui-color-blue-a400');
                    fileModeBtn.classList.add('mdui-color-blue-a400');
                    ciphertext.classList.add('hidden');
                    dropArea.classList.remove('hidden');
                }
                validateInput();
            }

            function validateInput() {
                let isValid = false;
                if (currentMode === 'text') {
                    const text = ciphertext.value.trim();
                    isValid = text.includes('-----BEGIN PGP MESSAGE-----') && 
                             text.includes('-----END PGP MESSAGE-----');
                } else {
                    isValid = fileInput.files.length > 0 && 
                             (fileInput.files[0].name.endsWith('.gpg') || 
                              fileInput.files[0].name.endsWith('.asc'));
                }
                decryptBtn.disabled = !isValid;
            }

            // Event listeners
            textModeBtn.addEventListener('click', () => switchMode('text'));
            fileModeBtn.addEventListener('click', () => switchMode('file'));
            ciphertext.addEventListener('input', validateInput);
            
            dropArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropArea.classList.add('highlight');
            });

            dropArea.addEventListener('dragleave', () => {
                dropArea.classList.remove('highlight');
            });

            dropArea.addEventListener('drop', (e) => {
                e.preventDefault();
                dropArea.classList.remove('highlight');
                handleFiles(e.dataTransfer.files);
            });

            dropArea.addEventListener('click', () => {
                fileInput.click();
            });

            fileInput.addEventListener('change', (e) => {
                handleFiles(e.target.files);
            });

            pasteBtn.addEventListener('click', async () => {
                try {
                    const text = await navigator.clipboard.readText();
                    ciphertext.value = text;
                    validateInput();
                } catch (err) {
                    mdui.snackbar({
                        message: 'Failed to paste from clipboard',
                        timeout: 2000
                    });
                }
            });

            clearBtn.addEventListener('click', () => {
                if (currentMode === 'text') {
                    ciphertext.value = '';
                } else {
                    fileInput.value = '';
                    fileInfo.textContent = '';
                }
                validateInput();
            });

            function handleFiles(files) {
                if (!files.length) return;
                const file = files[0];
                if (!file.name.endsWith('.gpg') && !file.name.endsWith('.asc')) {
                    mdui.snackbar({
                        message: 'Please select a .gpg or .asc file',
                        timeout: 2000
                    });
                    return;
                }
                fileInfo.textContent = `Selected file: ${file.name}`;
                validateInput();
            }

            // 解密函数
            async function decryptMessage(encryptedData) {
                try {
                    const message = await openpgp.readMessage({
                        armoredMessage: encryptedData
                    });

                    // 使用Yubikey进行解密
                    const decryptedData = await yubikey.decrypt(message.packets[0].encrypted);
                    
                    // 验证签名
                    let signatures = [];
                    if (message.signatures.length > 0) {
                        signatures = await Promise.all(message.signatures.map(async (sig) => {
                            try {
                                const key = await KeyServer.getKey(sig.keyid);
                                await openpgp.verify({
                                    message: message,
                                    verificationKeys: key
                                });
                                return {
                                    valid: true,
                                    keyid: sig.keyid,
                                    key: key
                                };
                            } catch (e) {
                                return {
                                    valid: false,
                                    keyid: sig.keyid,
                                    error: e.message
                                };
                            }
                        }));
                    }

                    return {
                        data: new TextDecoder().decode(decryptedData),
                        signatures: signatures
                    };
                } catch (error) {
                    console.error('Decryption error:', error);
                    throw new Error('Decryption failed: ' + error.message);
                }
            }

            // 处理签名验证
            async function verifySignature(signatures) {
                if (!signatures || signatures.length === 0) {
                    return {
                        valid: false,
                        message: 'No signature found'
                    };
                }

                try {
                    const results = await Promise.all(signatures.map(async (sig) => {
                        try {
                            await sig.verified;
                            return {
                                valid: true,
                                keyid: sig.keyid,
                                created: sig.created
                            };
                        } catch (e) {
                            return {
                                valid: false,
                                keyid: sig.keyid,
                                error: e.message
                            };
                        }
                    }));

                    return {
                        valid: results.some(r => r.valid),
                        details: results
                    };
                } catch (error) {
                    return {
                        valid: false,
                        message: error.message
                    };
                }
            }

            // 显示解密结果
            function showDecryptedContent(content, signatureInfo) {
                const resultSection = document.createElement('div');
                resultSection.id = 'decryptedContent';
                resultSection.className = 'section';

                // 添加解密内容
                const contentDiv = document.createElement('div');
                contentDiv.className = 'mdui-typo';
                contentDiv.innerHTML = `
                    <h3>Decrypted Content</h3>
                    <pre class="mdui-shadow-1">${escapeHtml(content)}</pre>
                `;
                resultSection.appendChild(contentDiv);

                // 添加签名信息
                if (signatureInfo) {
                    const sigDiv = document.createElement('div');
                    sigDiv.className = `signature-info ${signatureInfo.valid ? 'signature-valid' : 'signature-invalid'}`;
                    sigDiv.innerHTML = `
                        <i class="mdui-icon material-icons">${signatureInfo.valid ? 'verified_user' : 'warning'}</i>
                        <span>${signatureInfo.valid ? 'Valid signature' : 'Invalid signature'}</span>
                        ${signatureInfo.message ? `<br>${signatureInfo.message}` : ''}
                    `;
                    resultSection.appendChild(sigDiv);
                }

                // 移除旧的结果（如果存在）
                const oldResult = document.getElementById('decryptedContent');
                if (oldResult) {
                    oldResult.remove();
                }

                // 插入新结果
                document.querySelector('.section:last-child').after(resultSection);
                resultSection.style.display = 'block';
            }

            // HTML转义函数
            function escapeHtml(unsafe) {
                return unsafe
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#039;");
            }

            // 修改解密按钮点击事件
            async function handleDecrypt() {
                if (!yubikey) {
                    await connectYubikey();
                    if (!yubikey) return;
                }

                try {
                    const pin = await showPINDialog();
                    await verifyPIN(pin);

                    let encryptedData;
                    if (currentMode === 'text') {
                        encryptedData = ciphertext.value.trim();
                    } else {
                        const file = fileInput.files[0];
                        encryptedData = await readFileAsText(file);
                    }

                    const { data, signatures } = await decryptMessage(encryptedData);
                    const sigInfo = await verifySignature(signatures);
                    showDecryptedContent(data, sigInfo);

                } catch (error) {
                    mdui.snackbar({
                        message: error.message,
                        timeout: 2000
                    });
                }
            }

            // 文件读取函数
            function readFileAsText(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = e => resolve(e.target.result);
                    reader.onerror = e => reject(e);
                    reader.readAsText(file);
                });
            }

            // 初始化
            async function initialize() {
                // 获取帮助按钮并添加事件监听器
                const helpBtn = document.getElementById('helpBtn');
                helpBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // 阻止事件冒泡，避免触发yubikey状态的点击事件
                    showLinuxHelp();
                });
                
                // 检测操作系统是否为Linux
                const isLinux = navigator.platform.includes('Linux');
                if (isLinux) {
                    // 为Linux用户添加额外的提示
                    mdui.snackbar({
                        message: 'Linux users may need special USB permissions. Click the help icon for details.',
                        timeout: 5000
                    });
                }

                if (!checkWebUSBSupport()) {
                    decryptBtn.disabled = true;
                    // 提供降级方案建议
                    mdui.snackbar({
                        message: 'Suggestion: Try using desktop OpenPGP software like Gpg4win or GnuPG',
                        timeout: 5000,
                        position: 'top'
                    });
                    return;
                }
                
                // 尝试自动连接之前已配对的Yubikey
                try {
                    const devices = await navigator.usb.getDevices();
                    if (devices.length > 0) {
                        yubikey = new YubikeyPGP(devices[0]);
                        await yubikey.connect();
                        updateYubikeyStatus('ready', 'Yubikey connected');
                    } else {
                        updateYubikeyStatus('connecting', 'Click to connect Yubikey');
                        // 添加工具提示，指导用户
                        mdui.snackbar({
                            message: 'Click on the status indicator to connect your Yubikey',
                            timeout: 3000
                        });
                    }
                } catch (error) {
                    console.error('Auto-connect error:', error);
                    updateYubikeyStatus('error', 'Failed to auto-connect. Click to try again.');
                }
                
                // 添加Yubikey状态点击事件
                yubikeyStatus.addEventListener('click', async () => {
                    if (!yubikey) {
                        await connectYubikey();
                    }
                });
                
                // 修改解密按钮点击事件
                decryptBtn.addEventListener('click', handleDecrypt);
                
                mdui.mutation();
            }

            // 初始化应用
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initialize);
            } else {
                initialize();
            }
        })();
    </script>
</body>
</html>
