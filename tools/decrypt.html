<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PGP Decryption Tool</title>
    <link rel="stylesheet" href="https://unpkg.com/mdui@1.0.2/dist/css/mdui.min.css">
    <script src="https://unpkg.com/mdui@1.0.2/dist/js/mdui.min.js"></script>

    <style>
        body {
            max-width: 800px;
            margin: 0 auto;
            padding: 15px;
            background-color: var(--mdui-color-background);
            color: var(--mdui-color-text);
        }
        
        textarea, #dropArea {
            width: 100%;
            box-sizing: border-box;
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
            background-color: var(--mdui-color-surface);
            color: var(--mdui-color-text);
            transition: all 0.3s;
        }
        
        textarea {
            resize: vertical;
            min-height: 100px;
            border: 1px solid rgba(0,0,0,0.12);
        }
        
        #dropArea {
            border: 2px dashed rgba(0,0,0,0.12);
            padding: 25px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        #dropArea.highlight {
            border-color: var(--mdui-color-primary);
            background-color: var(--mdui-color-primary-container);
            color: var(--mdui-color-on-primary-container);
        }

        .yubikey-status {
            display: flex;
            align-items: center;
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
            background-color: var(--mdui-color-surface-variant);
            cursor: pointer; /* 添加指针样式表明可点击 */
            position: relative;
        }

        .yubikey-status .help-icon {
            position: absolute;
            right: 10px;
            color: var(--mdui-color-primary);
            cursor: help;
        }

        .yubikey-status .status-icon {
            margin-right: 10px;
        }

        .status-connecting {
            color: var(--mdui-color-warning);
        }

        .status-ready {
            color: var(--mdui-color-success);
        }

        .status-error {
            color: var(--mdui-color-error);
        }

        @media (prefers-color-scheme: dark) {
            body {
                background-color: var(--mdui-color-surface);
                color: var (--mdui-color-on-surface);
            }
            
            textarea, #dropArea {
                background-color: var(--mdui-color-surface-container);
                color: var (--mdui-color-on-surface);
                border-color: rgba(255,255,255,0.12);
            }
        }

        /* PIN输入对话框样式 */
        .pin-dialog {
            max-width: 300px;
            margin: 0 auto;
        }
        
        .pin-input {
            letter-spacing: 0.5em;
            text-align: center;
            font-family: monospace;
        }
        
        .pin-error {
            color: var(--mdui-color-error);
            font-size: 0.85em;
            margin-top: 8px;
            display: none;
        }

        /* 解密结果区域样式 */
        #decryptedContent {
            margin-top: 20px;
            display: none;
        }

        .signature-info {
            margin-top: 10px;
            padding: 8px;
            border-radius: 4px;
            background-color: var(--mdui-color-surface-variant);
        }

        .signature-valid {
            color: var(--mdui-color-success);
        }

        .signature-invalid {
            color: var(--mdui-color-error);
        }
    </style>
</head>
<body class="mdui-theme-primary-indigo mdui-theme-accent-blue">
    <div class="section mdui-typo">
        <h2 class="mdui-typo-headline" style="text-align: center;">PGP Decryption Tool</h2>
        <p>Decrypt your PGP messages using Yubikey securely in your browser.</p>
    </div>

    <div class="yubikey-status mdui-shadow-1">
        <i class="mdui-icon material-icons status-icon status-connecting">sync</i>
        <span>Waiting for Yubikey...</span>
        <i class="mdui-icon material-icons help-icon" id="helpBtn" title="USB Device Help">help_outline</i>
    </div>

    <div class="section">
        <div class="mode-buttons mdui-btn-group">
            <button id="textModeBtn" class="mdui-btn mdui-btn-raised mdui-ripple mdui-color-blue-a400">
                <i class="mdui-icon material-icons">text_fields</i> Text
            </button>
            <button id="fileModeBtn" class="mdui-btn mdui-color-white mdui-shadow-1 mdui-ripple">
                <i class="mdui-icon material-icons">file_upload</i> File
            </button>
        </div>
        
        <div class="input-container mdui-textfield mdui-textfield-floating-label">
            <textarea id="ciphertext" class="mdui-textfield-input mdui-ripple mdui-shadow-1 mdui-color-grey-200" 
                      placeholder="Paste your encrypted PGP message here"></textarea>
            
            <div id="dropArea" class="hidden mdui-shadow-1 mdui-color-white">
                Drag encrypted file here or click to upload
                <input type="file" id="fileInput" style="display:none;" accept=".gpg,.asc" />
            </div>
            <div id="fileInfo" class="mdui-typo-caption-opacity"></div>
        </div>

        <div class="mdui-btn-group">
            <button id="pasteBtn" class="mdui-btn mdui-btn-raised mdui-ripple mdui-color-white">
                <i class="mdui-icon material-icons">content_paste</i> Paste
            </button>
            <button id="clearBtn" class="mdui-btn mdui-ripple mdui-color-white">
                <i class="mdui-icon material-icons">clear</i> Clear
            </button>
            <button id="decryptBtn" class="mdui-btn mdui-btn-raised mdui-ripple mdui-color-theme" disabled>
                <i class="mdui-icon material-icons">lock_open</i> Decrypt
            </button>
        </div>
    </div>

    <!-- OpenPGP.js -->
    <script src="https://unpkg.com/openpgp@5.9.0/dist/openpgp.min.js"></script>
    <!-- WebUSB Polyfill -->
    <script src="https://gcore.jsdelivr.net/npm/webusb/dist/webusb.js"></script>
    
    <script>
        (function() {
            // 常量定义
            const YUBIKEY_VENDOR_ID = 0x1050;
            // 添加所有已知的Yubikey产品ID
            const YUBIKEY_PRODUCT_IDS = [
                0x0113, // Yubikey NEO
                0x0114, // Yubikey NEO OTP+U2F
                0x0115, // Yubikey NEO OTP+U2F+CCID
                0x0116, // Yubikey NEO CCID
                0x0120, // Yubikey 4 OTP
                0x0121, // Yubikey 4 U2F
                0x0401, // Yubikey 4 OTP+U2F
                0x0402, // Yubikey 4 OTP+U2F+CCID
                0x0403, // Yubikey 4 CCID
                0x0404, // Yubikey 4 OTP+CCID
                0x0405, // Security Key by Yubico
                0x0406, // Yubikey 4 U2F+CCID
                0x0407, // Yubikey 5 (all versions)
                0x0410  // Yubikey 5 FIPS (all versions)
            ];
            const OpenPGP_AID = new Uint8Array([0xD2, 0x76, 0x00, 0x01, 0x24, 0x01]);
            const INS = {
                VERIFY: 0x20,
                GET_DATA: 0xCA,
                PUT_DATA: 0xDA,
                GENERATE: 0x47,
                AUTHENTICATE: 0x87
            };
            
            // 添加命令和响应调试
            const DEBUG = false; // 设置为true启用调试日志
            
            // 全局变量
            let yubikey = null;
            let currentMode = 'text';
            let pinAttempts = 3;
            let privateKey = null; // 将从Yubikey获取
            
            // DOM元素
            const textModeBtn = document.getElementById('textModeBtn');
            const fileModeBtn = document.getElementById('fileModeBtn');
            const ciphertext = document.getElementById('ciphertext');
            const dropArea = document.getElementById('dropArea');
            const fileInput = document.getElementById('fileInput');
            const fileInfo = document.getElementById('fileInfo');
            const decryptBtn = document.getElementById('decryptBtn');
            const pasteBtn = document.getElementById('pasteBtn');
            const clearBtn = document.getElementById('clearBtn');
            const yubikeyStatus = document.querySelector('.yubikey-status');
            
            // 检查WebUSB支持
            function checkWebUSBSupport() {
                if (!navigator.usb) {
                    // 检测是否为移动设备
                    const isMobile = /Android|iPhone|iPad|iPod|webOS/i.test(navigator.userAgent);
                    if (isMobile) {
                        updateYubikeyStatus('error', 'Mobile devices do not support WebUSB. Please use a desktop browser or <a href="https://www.openkeychain.org/">OpenKeychain</a>');
                    } else {
                        updateYubikeyStatus('error', 'WebUSB not supported in this browser. Please use Chrome or Edge.');
                    }
                    return false;
                } else {
                    // 检查浏览器是否支持WebUSB功能
                    try {
                        const testSupport = navigator.usb.getDevices();
                        if (!testSupport || typeof testSupport.then !== 'function') {
                            updateYubikeyStatus('error', 'WebUSB API不完全支持。请使用最新版Chrome或Edge浏览器。');
                            return false;
                        }
                    } catch (e) {
                        console.error('WebUSB API测试失败:', e);
                        updateYubikeyStatus('error', 'WebUSB API不可用：' + e.message);
                        return false;
                    }
                }
                return true;
            }
            
            // 更新Yubikey状态显示
            function updateYubikeyStatus(status, message) {
                const statusIcon = yubikeyStatus.querySelector('.status-icon');
                const statusText = yubikeyStatus.querySelector('span');
                
                statusIcon.className = 'mdui-icon material-icons status-icon';
                switch(status) {
                    case 'connecting':
                        statusIcon.classList.add('status-connecting');
                        statusIcon.textContent = 'sync';
                        break;
                    case 'ready':
                        statusIcon.classList.add('status-ready');
                        statusIcon.textContent = 'check_circle';
                        break;
                    case 'error':
                        statusIcon.classList.add('status-error');
                        statusIcon.textContent = 'error';
                        break;
                }
                
                statusText.textContent = message;
            }
            
            // Yubikey通信类
            class YubikeyPGP {
                constructor(device) {
                    this.device = device;
                    this.iface = null;
                    this.endpoint = null;
                    this.responseMax = 64; // 默认响应缓冲区大小
                }

                async connect() {
                    try {
                        if (DEBUG) console.log('正在连接设备:', this.device);
                        
                        // 如果设备已打开，先关闭
                        if (this.device.opened) {
                            try {
                                await this.device.close();
                                if (DEBUG) console.log('关闭了已打开的设备');
                            } catch (e) {
                                console.warn('关闭已打开设备时出错:', e);
                                // 继续尝试打开设备
                            }
                        }
                        
                        await this.device.open();
                        
                        if (!this.device.opened) {
                            throw new Error('无法打开设备');
                        }
                        
                        if (DEBUG) console.log('设备已打开，选择配置');
                        
                        // 选择配置
                        if (this.device.configuration === null) {
                            await this.device.selectConfiguration(1);
                            if (DEBUG) console.log('已选择配置 1');
                        } else {
                            if (DEBUG) console.log('使用现有配置:', this.device.configuration);
                        }

                        // 获取接口
                        if (!this.device.configuration || !this.device.configuration.interfaces) {
                            throw new Error('设备没有可用接口');
                        }
                        
                        // 尝试找到CCID接口
                        let ccidInterface = null;
                        for (const iface of this.device.configuration.interfaces) {
                            if (iface.alternates && iface.alternates.length > 0) {
                                const alt = iface.alternates[0];
                                if (alt.interfaceClass === 0x0B) { // CCID类
                                    ccidInterface = iface;
                                    break;
                                }
                            }
                        }
                        
                        // 如果找不到CCID接口，使用第一个可用接口
                        const iface = ccidInterface || this.device.configuration.interfaces[0];
                        
                        if (DEBUG) console.log('使用接口:', iface);
                        
                        try {
                            await this.device.claimInterface(iface.interfaceNumber);
                            if (DEBUG) console.log('已申请接口:', iface.interfaceNumber);
                        } catch (e) {
                            throw new Error(`无法申请接口 ${iface.interfaceNumber}: ${e.message}`);
                        }
                        
                        // 查找并使用适当的端点
                        if (!iface.alternate || !iface.alternate.endpoints || iface.alternate.endpoints.length === 0) {
                            throw new Error('接口没有端点');
                        }
                        
                        // 查找批量输入和输出端点
                        let inEndpoint = null;
                        let outEndpoint = null;
                        
                        for (const endpoint of iface.alternate.endpoints) {
                            if (endpoint.direction === 'in' && endpoint.type === 'bulk') {
                                inEndpoint = endpoint;
                            } else if (endpoint.direction === 'out' && endpoint.type === 'bulk') {
                                outEndpoint = endpoint;
                            }
                        }
                        
                        // 如果找不到专用端点，使用第一个可用端点
                        this.inEndpoint = inEndpoint || iface.alternate.endpoints[0];
                        this.outEndpoint = outEndpoint || iface.alternate.endpoints[0];
                        
                        if (DEBUG) {
                            console.log('输入端点:', this.inEndpoint);
                            console.log('输出端点:', this.outEndpoint);
                        }
                        
                        this.iface = iface;
                        this.responseMax = this.inEndpoint.packetSize || 64;
                        
                        // 选择OpenPGP应用
                        await this.selectApplication(OpenPGP_AID);
                        if (DEBUG) console.log('已选择OpenPGP应用');
                        
                        return true;
                    } catch (error) {
                        console.error('Yubikey连接详细错误:', error);
                        
                        // 清理资源
                        if (this.device.opened) {
                            try {
                                if (this.iface) {
                                    await this.device.releaseInterface(this.iface.interfaceNumber);
                                }
                                await this.device.close();
                            } catch (closeError) {
                                console.error('关闭设备时出错:', closeError);
                            }
                        }
                        throw error;
                    }
                }

                async selectApplication(aid) {
                    if (DEBUG) console.log('选择应用:', Array.from(aid).map(b => b.toString(16).padStart(2, '0')).join(' '));
                    const result = await this.transmit(0x00, 0xA4, 0x04, 0x00, aid);
                    if (!this.isSuccessResponse(result)) {
                        throw new Error('无法选择OpenPGP应用');
                    }
                    return result;
                }

                async verifyPin(pin) {
                    const pinBuffer = new TextEncoder().encode(pin);
                    if (DEBUG) console.log('验证PIN');
                    const result = await this.transmit(0x00, INS.VERIFY, 0x00, 0x82, pinBuffer);
                    return this.isSuccessResponse(result);
                }

                async getPublicKey() {
                    if (DEBUG) console.log('获取公钥');
                    const result = await this.transmit(0x00, INS.GET_DATA, 0x00, 0x82, null);
                    if (!this.isSuccessResponse(result)) {
                        throw new Error('无法获取公钥');
                    }
                    return result.slice(0, -2);
                }

                async decrypt(encryptedData) {
                    if (DEBUG) console.log('解密数据');
                    try {
                        const result = await this.transmit(0x00, INS.AUTHENTICATE, 0x07, 0x00, encryptedData);
                        if (!this.isSuccessResponse(result)) {
                            throw new Error('解密失败');
                        }
                        return result.slice(0, -2);
                    } catch (error) {
                        console.error('解密过程中出错:', error);
                        throw new Error('解密失败: ' + error.message);
                    }
                }

                async transmit(cla, ins, p1, p2, data) {
                    const command = this.buildApdu(cla, ins, p1, p2, data);
                    
                    if (DEBUG) {
                        console.log('发送APDU命令:', 
                            Array.from(command).map(b => b.toString(16).padStart(2, '0')).join(' '));
                    }
                    
                    // 发送命令到设备
                    try {
                        await this.device.transferOut(
                            this.outEndpoint.endpointNumber, 
                            command.buffer
                        );
                    } catch (e) {
                        console.error('发送命令失败:', e);
                        throw new Error('通信错误: ' + e.message);
                    }
                    
                    // 从设备读取响应
                    let response;
                    try {
                        response = await this.device.transferIn(
                            this.inEndpoint.endpointNumber, 
                            this.responseMax
                        );
                    } catch (e) {
                        console.error('接收响应失败:', e);
                        throw new Error('读取响应错误: ' + e.message);
                    }
                    
                    const result = new Uint8Array(response.data.buffer);
                    
                    if (DEBUG) {
                        console.log('收到响应:', 
                            Array.from(result).map(b => b.toString(16).padStart(2, '0')).join(' '));
                    }
                    
                    return result;
                }

                buildApdu(cla, ins, p1, p2, data) {
                    if (!data) {
                        // Case 1: 无数据发送、无数据接收
                        return new Uint8Array([cla, ins, p1, p2, 0x00]);
                    }
                    
                    if (data.length <= 255) {
                        // Case 3S: 短数据发送
                        const header = new Uint8Array([cla, ins, p1, p2, data.length]);
                        return new Uint8Array([...header, ...data]);
                    } else {
                        // Case 3E: 扩展数据发送
                        const header = new Uint8Array([cla, ins, p1, p2, 0x00, 
                            (data.length >> 8) & 0xFF, data.length & 0xFF]);
                        return new Uint8Array([...header, ...data]);
                    }
                }

                isSuccessResponse(response) {
                    if (response.length < 2) {
                        return false;
                    }
                    return response[response.length - 2] === 0x90 && 
                           response[response.length - 1] === 0x00;
                }
                
                // 获取状态码说明
                getStatusMessage(sw1, sw2) {
                    const status = (sw1 << 8) | sw2;
                    switch(status) {
                        case 0x9000: return "成功";
                        case 0x6982: return "安全状态不满足 - PIN验证失败";
                        case 0x6983: return "验证方法被锁定 - PIN已被锁定";
                        case 0x6985: return "使用条件不满足";
                        case 0x6A80: return "参数错误 - 数据格式错误";
                        case 0x6A81: return "功能不支持";
                        case 0x6A82: return "文件未找到 - 应用未找到";
                        case 0x6A83: return "记录未找到";
                        case 0x6A86: return "P1/P2参数错误";
                        case 0x6A87: return "Lc与数据长度不一致";
                        case 0x6D00: return "指令不支持";
                        case 0x6E00: return "类不支持";
                        case 0x6F00: return "未知错误";
                        default: return `未知状态码: ${sw1.toString(16).padStart(2, '0')}${sw2.toString(16).padStart(2, '0')}`;
                    }
                }
            }

            // key.openpgp.org API集成
            class KeyServer {
                static async getKey(keyId) {
                    try {
                        const response = await fetch(`https://keys.openpgp.org/vks/v1/by-keyid/${keyId}`);
                        if (!response.ok) {
                            throw new Error('Key not found');
                        }
                        const armored = await response.text();
                        return await openpgp.readKey({ armoredKey: armored });
                    } catch (error) {
                        console.error('Key server error:', error);
                        throw new Error('Failed to fetch key from server');
                    }
                }
            }

            // 连接Yubikey
            async function connectYubikey() {
                try {
                    // 显示连接中状态
                    updateYubikeyStatus('connecting', 'Connecting to Yubikey...');
                    
                    // 创建所有Yubikey产品ID的过滤器数组
                    const filters = YUBIKEY_PRODUCT_IDS.map(productId => ({
                        vendorId: YUBIKEY_VENDOR_ID,
                        productId: productId
                    }));
                    
                    // 添加一个仅有vendorId的过滤器，以匹配可能的其他产品
                    filters.push({ vendorId: YUBIKEY_VENDOR_ID });
                    
                    if (DEBUG) console.log('使用USB设备过滤器:', filters);
                    
                    const device = await navigator.usb.requestDevice({
                        filters: filters
                    });
                    
                    if (DEBUG) console.log('找到设备:', device);
                    
                    yubikey = new YubikeyPGP(device);
                    await yubikey.connect();
                    updateYubikeyStatus('ready', 'Yubikey connected');
                    validateInput();
                    
                } catch (error) {
                    console.error('Yubikey连接错误:', error);
                    
                    // 提供更具体的错误信息
                    if (error.name === 'NotFoundError') {
                        updateYubikeyStatus('error', '找不到兼容设备。请确保您的Yubikey已插入。');
                    } else if (error.name === 'SecurityError') {
                        // Linux 特有问题
                        if (navigator.platform.includes('Linux')) {
                            updateYubikeyStatus('error', '权限被拒绝。在Linux上，您可能需要添加udev规则。');
                            showLinuxHelp();
                        } else {
                            updateYubikeyStatus('error', '访问被拒绝。尝试使用不同的USB端口，或重新插入设备。');
                        }
                    } else {
                        // 提供更详细的错误信息
                        let errorMsg = '连接失败: ' + error.message;
                        
                        // 检查是否为常见的错误
                        if (error.message.includes('Failed to claim interface')) {
                            errorMsg = '接口冲突: Yubikey可能被其他程序占用。请关闭可能使用Yubikey的其他应用。';
                        } else if (error.message.includes('Failed to select OpenPGP application')) {
                            errorMsg = '无法访问OpenPGP应用: 您的Yubikey可能未配置OpenPGP功能。';
                        }
                        
                        updateYubikeyStatus('error', errorMsg);
                    }
                    
                    throw error;
                }
            }
            
            // 显示Linux帮助对话框
            function showLinuxHelp() {
                mdui.dialog({
                    title: 'Linux USB 权限设置',
                    content: `
                        <p>在Linux上，您需要添加udev规则来访问USB设备：</p>
                        <pre class="mdui-typo-pre">
# 创建此文件: /etc/udev/rules.d/70-yubikey.rules
# Yubikey 4/5
SUBSYSTEM=="usb", ATTRS{idVendor}=="1050", ATTRS{idProduct}=="0407", MODE="0666"
# Yubikey NEO
SUBSYSTEM=="usb", ATTRS{idVendor}=="1050", ATTRS{idProduct}=="0113", MODE="0666"
# 其他Yubikey设备
SUBSYSTEM=="usb", ATTRS{idVendor}=="1050", MODE="0666"

# 然后运行
sudo udevadm control --reload-rules && sudo udevadm trigger</pre>
                        <p>完成后，拔出并重新插入您的Yubikey，然后刷新页面重试。</p>
                    `,
                    buttons: [
                        {
                            text: '复制规则',
                            onClick: function() {
                                const rules = `# Yubikey 4/5
SUBSYSTEM=="usb", ATTRS{idVendor}=="1050", ATTRS{idProduct}=="0407", MODE="0666"
# Yubikey NEO
SUBSYSTEM=="usb", ATTRS{idVendor}=="1050", ATTRS{idProduct}=="0113", MODE="0666"
# 其他Yubikey设备
SUBSYSTEM=="usb", ATTRS{idVendor}=="1050", MODE="0666"`;
                                
                                navigator.clipboard.writeText(rules).then(() => {
                                    mdui.snackbar({
                                        message: '已复制到剪贴板',
                                        timeout: 2000
                                    });
                                });
                            }
                        },
                        {
                            text: '确定'
                        }
                    ]
                });
            }

            // 显示PIN输入对话框
            function showPINDialog() {
                return new Promise((resolve, reject) => {
                    const dialog = new mdui.Dialog(`
                        <div class="pin-dialog mdui-dialog">
                            <div class="mdui-dialog-title">Enter PIN</div>
                            <div class="mdui-dialog-content">
                                <div class="mdui-textfield">
                                    <input type="password" class="mdui-textfield-input pin-input" 
                                           pattern="[0-9]*" inputmode="numeric" maxlength="8" 
                                           placeholder="Enter your PIN"/>
                                </div>
                                <div class="pin-error">Invalid PIN, ${pinAttempts} attempts remaining</div>
                            </div>
                            <div class="mdui-dialog-actions">
                                <button class="mdui-btn mdui-ripple" mdui-dialog-cancel>Cancel</button>
                                <button class="mdui-btn mdui-ripple" mdui-dialog-confirm>OK</button>
                            </div>
                        </div>
                    `, {
                        closeOnEsc: false,
                        modal: true
                    });
                    
                    const pinInput = dialog.$element.querySelector('.pin-input');
                    const errorDiv = dialog.$element.querySelector('.pin-error');
                    
                    dialog.open();
                    
                    dialog.$element.addEventListener('confirm', () => {
                        const pin = pinInput.value;
                        if (pin.length >= 4) {
                            resolve(pin);
                        } else {
                            errorDiv.textContent = 'PIN must be at least 4 digits';
                            errorDiv.style.display = 'block';
                            return false;
                        }
                    });
                    
                    dialog.$element.addEventListener('cancel', () => {
                        reject(new Error('PIN entry cancelled'));
                    });
                });
            }
            
            // 验证PIN
            async function verifyPIN(pin) {
                try {
                    const result = await yubikey.verifyPin(pin);
                    if (!result) {
                        pinAttempts--;
                        if (pinAttempts <= 0) {
                            throw new Error('PIN blocked');
                        }
                        throw new Error(`Invalid PIN, ${pinAttempts} attempts remaining`);
                    }
                    return true;
                } catch (error) {
                    console.error('PIN verification error:', error);
                    throw error;
                }
            }

            function switchMode(mode) {
                currentMode = mode;
                if (mode === 'text') {
                    textModeBtn.classList.add('mdui-color-blue-a400');
                    fileModeBtn.classList.remove('mdui-color-blue-a400');
                    ciphertext.classList.remove('hidden');
                    dropArea.classList.add('hidden');
                } else {
                    textModeBtn.classList.remove('mdui-color-blue-a400');
                    fileModeBtn.classList.add('mdui-color-blue-a400');
                    ciphertext.classList.add('hidden');
                    dropArea.classList.remove('hidden');
                }
                validateInput();
            }

            function validateInput() {
                let isValid = false;
                if (currentMode === 'text') {
                    const text = ciphertext.value.trim();
                    isValid = text.includes('-----BEGIN PGP MESSAGE-----') && 
                             text.includes('-----END PGP MESSAGE-----');
                } else {
                    isValid = fileInput.files.length > 0 && 
                             (fileInput.files[0].name.endsWith('.gpg') || 
                              fileInput.files[0].name.endsWith('.asc'));
                }
                decryptBtn.disabled = !isValid;
            }

            // Event listeners
            textModeBtn.addEventListener('click', () => switchMode('text'));
            fileModeBtn.addEventListener('click', () => switchMode('file'));
            ciphertext.addEventListener('input', validateInput);
            
            dropArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropArea.classList.add('highlight');
            });

            dropArea.addEventListener('dragleave', () => {
                dropArea.classList.remove('highlight');
            });

            dropArea.addEventListener('drop', (e) => {
                e.preventDefault();
                dropArea.classList.remove('highlight');
                handleFiles(e.dataTransfer.files);
            });

            dropArea.addEventListener('click', () => {
                fileInput.click();
            });

            fileInput.addEventListener('change', (e) => {
                handleFiles(e.target.files);
            });

            pasteBtn.addEventListener('click', async () => {
                try {
                    const text = await navigator.clipboard.readText();
                    ciphertext.value = text;
                    validateInput();
                } catch (err) {
                    mdui.snackbar({
                        message: 'Failed to paste from clipboard',
                        timeout: 2000
                    });
                }
            });

            clearBtn.addEventListener('click', () => {
                if (currentMode === 'text') {
                    ciphertext.value = '';
                } else {
                    fileInput.value = '';
                    fileInfo.textContent = '';
                }
                validateInput();
            });

            function handleFiles(files) {
                if (!files.length) return;
                const file = files[0];
                if (!file.name.endsWith('.gpg') && !file.name.endsWith('.asc')) {
                    mdui.snackbar({
                        message: 'Please select a .gpg or .asc file',
                        timeout: 2000
                    });
                    return;
                }
                fileInfo.textContent = `Selected file: ${file.name}`;
                validateInput();
            }

            // 解密函数
            async function decryptMessage(encryptedData) {
                try {
                    const message = await openpgp.readMessage({
                        armoredMessage: encryptedData
                    });

                    // 使用Yubikey进行解密
                    const decryptedData = await yubikey.decrypt(message.packets[0].encrypted);
                    
                    // 验证签名
                    let signatures = [];
                    if (message.signatures.length > 0) {
                        signatures = await Promise.all(message.signatures.map(async (sig) => {
                            try {
                                const key = await KeyServer.getKey(sig.keyid);
                                await openpgp.verify({
                                    message: message,
                                    verificationKeys: key
                                });
                                return {
                                    valid: true,
                                    keyid: sig.keyid,
                                    key: key
                                };
                            } catch (e) {
                                return {
                                    valid: false,
                                    keyid: sig.keyid,
                                    error: e.message
                                };
                            }
                        }));
                    }

                    return {
                        data: new TextDecoder().decode(decryptedData),
                        signatures: signatures
                    };
                } catch (error) {
                    console.error('Decryption error:', error);
                    throw new Error('Decryption failed: ' + error.message);
                }
            }

            // 处理签名验证
            async function verifySignature(signatures) {
                if (!signatures || signatures.length === 0) {
                    return {
                        valid: false,
                        message: 'No signature found'
                    };
                }

                try {
                    const results = await Promise.all(signatures.map(async (sig) => {
                        try {
                            await sig.verified;
                            return {
                                valid: true,
                                keyid: sig.keyid,
                                created: sig.created
                            };
                        } catch (e) {
                            return {
                                valid: false,
                                keyid: sig.keyid,
                                error: e.message
                            };
                        }
                    }));

                    return {
                        valid: results.some(r => r.valid),
                        details: results
                    };
                } catch (error) {
                    return {
                        valid: false,
                        message: error.message
                    };
                }
            }

            // 显示解密结果
            function showDecryptedContent(content, signatureInfo) {
                const resultSection = document.createElement('div');
                resultSection.id = 'decryptedContent';
                resultSection.className = 'section';

                // 添加解密内容
                const contentDiv = document.createElement('div');
                contentDiv.className = 'mdui-typo';
                contentDiv.innerHTML = `
                    <h3>Decrypted Content</h3>
                    <pre class="mdui-shadow-1">${escapeHtml(content)}</pre>
                `;
                resultSection.appendChild(contentDiv);

                // 添加签名信息
                if (signatureInfo) {
                    const sigDiv = document.createElement('div');
                    sigDiv.className = `signature-info ${signatureInfo.valid ? 'signature-valid' : 'signature-invalid'}`;
                    sigDiv.innerHTML = `
                        <i class="mdui-icon material-icons">${signatureInfo.valid ? 'verified_user' : 'warning'}</i>
                        <span>${signatureInfo.valid ? 'Valid signature' : 'Invalid signature'}</span>
                        ${signatureInfo.message ? `<br>${signatureInfo.message}` : ''}
                    `;
                    resultSection.appendChild(sigDiv);
                }

                // 移除旧的结果（如果存在）
                const oldResult = document.getElementById('decryptedContent');
                if (oldResult) {
                    oldResult.remove();
                }

                // 插入新结果
                document.querySelector('.section:last-child').after(resultSection);
                resultSection.style.display = 'block';
            }

            // HTML转义函数
            function escapeHtml(unsafe) {
                return unsafe
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#039;");
            }

            // 修改解密按钮点击事件
            async function handleDecrypt() {
                if (!yubikey) {
                    await connectYubikey();
                    if (!yubikey) return;
                }

                try {
                    const pin = await showPINDialog();
                    await verifyPIN(pin);

                    let encryptedData;
                    if (currentMode === 'text') {
                        encryptedData = ciphertext.value.trim();
                    } else {
                        const file = fileInput.files[0];
                        encryptedData = await readFileAsText(file);
                    }

                    const { data, signatures } = await decryptMessage(encryptedData);
                    const sigInfo = await verifySignature(signatures);
                    showDecryptedContent(data, sigInfo);

                } catch (error) {
                    mdui.snackbar({
                        message: error.message,
                        timeout: 2000
                    });
                }
            }

            // 文件读取函数
            function readFileAsText(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = e => resolve(e.target.result);
                    reader.onerror = e => reject(e);
                    reader.readAsText(file);
                });
            }

            // 初始化
            async function initialize() {
                // 获取帮助按钮并添加事件监听器
                const helpBtn = document.getElementById('helpBtn');
                helpBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // 阻止事件冒泡，避免触发yubikey状态的点击事件
                    showLinuxHelp();
                });
                
                // 检测操作系统是否为Linux
                const isLinux = navigator.platform.includes('Linux');
                if (isLinux) {
                    // 为Linux用户添加额外的提示
                    mdui.snackbar({
                        message: 'Linux users may need special USB permissions. Click the help icon for details.',
                        timeout: 5000
                    });
                }

                if (!checkWebUSBSupport()) {
                    decryptBtn.disabled = true;
                    // 提供降级方案建议
                    mdui.snackbar({
                        message: 'Suggestion: Try using desktop OpenPGP software like Gpg4win or GnuPG',
                        timeout: 5000,
                        position: 'top'
                    });
                    return;
                }
                
                // 尝试自动连接之前已配对的Yubikey
                try {
                    const devices = await navigator.usb.getDevices();
                    if (DEBUG) console.log('找到已授权设备:', devices);
                    
                    if (devices.length > 0) {
                        // 尝试找到Yubikey设备
                        const yubikeys = devices.filter(dev => dev.vendorId === YUBIKEY_VENDOR_ID);
                        
                        if (yubikeys.length > 0) {
                            yubikey = new YubikeyPGP(yubikeys[0]);
                            await yubikey.connect();
                            updateYubikeyStatus('ready', 'Yubikey connected');
                        } else {
                            updateYubikeyStatus('connecting', 'Click to connect Yubikey');
                            mdui.snackbar({
                                message: '找不到Yubikey设备。点击状态指示器连接您的Yubikey。',
                                timeout: 3000
                            });
                        }
                    } else {
                        updateYubikeyStatus('connecting', 'Click to connect Yubikey');
                        mdui.snackbar({
                            message: '点击状态指示器连接您的Yubikey',
                            timeout: 3000
                        });
                    }
                } catch (error) {
                    console.error('自动连接错误:', error);
                    updateYubikeyStatus('error', '自动连接失败。点击重试。');
                }
                
                // 添加调试切换功能
                document.addEventListener('keydown', function(e) {
                    // Ctrl+Shift+D启用调试
                    if (e.ctrlKey && e.shiftKey && e.key === 'D') {
                        DEBUG = !DEBUG;
                        mdui.snackbar({
                            message: DEBUG ? '调试模式已启用' : '调试模式已禁用',
                            timeout: 2000
                        });
                    }
                });
                
                // 添加Yubikey状态点击事件
                yubikeyStatus.addEventListener('click', async () => {
                    if (!yubikey) {
                        await connectYubikey();
                    }
                });
                
                // 修改解密按钮点击事件
                decryptBtn.addEventListener('click', handleDecrypt);
                
                mdui.mutation();
            }

            // 初始化应用
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initialize);
            } else {
                initialize();
            }
        })();
    </script>
</body>
</html>
